{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport { ref, watch, nextTick } from 'vue';\nimport { shouldIgnoreKey } from '../../utils/private/key-composition.js'; // leave NAMED_MASKS at top of file (code referenced from docs)\n\nconst NAMED_MASKS = {\n  date: '####/##/##',\n  datetime: '####/##/## ##:##',\n  time: '##:##',\n  fulltime: '##:##:##',\n  phone: '(###) ### - ####',\n  card: '#### #### #### ####'\n};\nconst TOKENS = {\n  '#': {\n    pattern: '[\\\\d]',\n    negate: '[^\\\\d]'\n  },\n  S: {\n    pattern: '[a-zA-Z]',\n    negate: '[^a-zA-Z]'\n  },\n  N: {\n    pattern: '[0-9a-zA-Z]',\n    negate: '[^0-9a-zA-Z]'\n  },\n  A: {\n    pattern: '[a-zA-Z]',\n    negate: '[^a-zA-Z]',\n    transform: v => v.toLocaleUpperCase()\n  },\n  a: {\n    pattern: '[a-zA-Z]',\n    negate: '[^a-zA-Z]',\n    transform: v => v.toLocaleLowerCase()\n  },\n  X: {\n    pattern: '[0-9a-zA-Z]',\n    negate: '[^0-9a-zA-Z]',\n    transform: v => v.toLocaleUpperCase()\n  },\n  x: {\n    pattern: '[0-9a-zA-Z]',\n    negate: '[^0-9a-zA-Z]',\n    transform: v => v.toLocaleLowerCase()\n  }\n};\nconst KEYS = Object.keys(TOKENS);\nKEYS.forEach(key => {\n  TOKENS[key].regex = new RegExp(TOKENS[key].pattern);\n});\nconst tokenRegexMask = new RegExp('\\\\\\\\([^.*+?^${}()|([\\\\]])|([.*+?^${}()|[\\\\]])|([' + KEYS.join('') + '])|(.)', 'g'),\n      escRegex = /[.*+?^${}()|[\\]\\\\]/g;\nconst MARKER = String.fromCharCode(1);\nexport const useMaskProps = {\n  mask: String,\n  reverseFillMask: Boolean,\n  fillMask: [Boolean, String],\n  unmaskedValue: Boolean\n};\nexport default function (props, emit, emitValue, inputRef) {\n  let maskMarked, maskReplaced, computedMask, computedUnmask;\n  const hasMask = ref(null);\n  const innerValue = ref(getInitialMaskedValue());\n\n  function getIsTypeText() {\n    return props.autogrow === true || ['textarea', 'text', 'search', 'url', 'tel', 'password'].includes(props.type);\n  }\n\n  watch(() => props.type + props.autogrow, updateMaskInternals);\n  watch(() => props.mask, v => {\n    if (v !== void 0) {\n      updateMaskValue(innerValue.value, true);\n    } else {\n      const val = unmaskValue(innerValue.value);\n      updateMaskInternals();\n      props.modelValue !== val && emit('update:modelValue', val);\n    }\n  });\n  watch(() => props.fillMask + props.reverseFillMask, () => {\n    hasMask.value === true && updateMaskValue(innerValue.value, true);\n  });\n  watch(() => props.unmaskedValue, () => {\n    hasMask.value === true && updateMaskValue(innerValue.value);\n  });\n\n  function getInitialMaskedValue() {\n    updateMaskInternals();\n\n    if (hasMask.value === true) {\n      const masked = maskValue(unmaskValue(props.modelValue));\n      return props.fillMask !== false ? fillWithMask(masked) : masked;\n    }\n\n    return props.modelValue;\n  }\n\n  function getPaddedMaskMarked(size) {\n    if (size < maskMarked.length) {\n      return maskMarked.slice(-size);\n    }\n\n    let pad = '',\n        localMaskMarked = maskMarked;\n    const padPos = localMaskMarked.indexOf(MARKER);\n\n    if (padPos > -1) {\n      for (let i = size - localMaskMarked.length; i > 0; i--) {\n        pad += MARKER;\n      }\n\n      localMaskMarked = localMaskMarked.slice(0, padPos) + pad + localMaskMarked.slice(padPos);\n    }\n\n    return localMaskMarked;\n  }\n\n  function updateMaskInternals() {\n    hasMask.value = props.mask !== void 0 && props.mask.length > 0 && getIsTypeText();\n\n    if (hasMask.value === false) {\n      computedUnmask = void 0;\n      maskMarked = '';\n      maskReplaced = '';\n      return;\n    }\n\n    const localComputedMask = NAMED_MASKS[props.mask] === void 0 ? props.mask : NAMED_MASKS[props.mask],\n          fillChar = typeof props.fillMask === 'string' && props.fillMask.length > 0 ? props.fillMask.slice(0, 1) : '_',\n          fillCharEscaped = fillChar.replace(escRegex, '\\\\$&'),\n          unmask = [],\n          extract = [],\n          mask = [];\n    let firstMatch = props.reverseFillMask === true,\n        unmaskChar = '',\n        negateChar = '';\n    localComputedMask.replace(tokenRegexMask, (_, char1, esc, token, char2) => {\n      if (token !== void 0) {\n        const c = TOKENS[token];\n        mask.push(c);\n        negateChar = c.negate;\n\n        if (firstMatch === true) {\n          extract.push('(?:' + negateChar + '+)?(' + c.pattern + '+)?(?:' + negateChar + '+)?(' + c.pattern + '+)?');\n          firstMatch = false;\n        }\n\n        extract.push('(?:' + negateChar + '+)?(' + c.pattern + ')?');\n      } else if (esc !== void 0) {\n        unmaskChar = '\\\\' + (esc === '\\\\' ? '' : esc);\n        mask.push(esc);\n        unmask.push('([^' + unmaskChar + ']+)?' + unmaskChar + '?');\n      } else {\n        const c = char1 !== void 0 ? char1 : char2;\n        unmaskChar = c === '\\\\' ? '\\\\\\\\\\\\\\\\' : c.replace(escRegex, '\\\\\\\\$&');\n        mask.push(c);\n        unmask.push('([^' + unmaskChar + ']+)?' + unmaskChar + '?');\n      }\n    });\n    const unmaskMatcher = new RegExp('^' + unmask.join('') + '(' + (unmaskChar === '' ? '.' : '[^' + unmaskChar + ']') + '+)?' + '$'),\n          extractLast = extract.length - 1,\n          extractMatcher = extract.map((re, index) => {\n      if (index === 0 && props.reverseFillMask === true) {\n        return new RegExp('^' + fillCharEscaped + '*' + re);\n      } else if (index === extractLast) {\n        return new RegExp('^' + re + '(' + (negateChar === '' ? '.' : negateChar) + '+)?' + (props.reverseFillMask === true ? '$' : fillCharEscaped + '*'));\n      }\n\n      return new RegExp('^' + re);\n    });\n    computedMask = mask;\n\n    computedUnmask = val => {\n      const unmaskMatch = unmaskMatcher.exec(val);\n\n      if (unmaskMatch !== null) {\n        val = unmaskMatch.slice(1).join('');\n      }\n\n      const extractMatch = [],\n            extractMatcherLength = extractMatcher.length;\n\n      for (let i = 0, str = val; i < extractMatcherLength; i++) {\n        const m = extractMatcher[i].exec(str);\n\n        if (m === null) {\n          break;\n        }\n\n        str = str.slice(m.shift().length);\n        extractMatch.push(...m);\n      }\n\n      if (extractMatch.length > 0) {\n        return extractMatch.join('');\n      }\n\n      return val;\n    };\n\n    maskMarked = mask.map(v => typeof v === 'string' ? v : MARKER).join('');\n    maskReplaced = maskMarked.split(MARKER).join(fillChar);\n  }\n\n  function updateMaskValue(rawVal, updateMaskInternalsFlag, inputType) {\n    const inp = inputRef.value,\n          end = inp.selectionEnd,\n          endReverse = inp.value.length - end,\n          unmasked = unmaskValue(rawVal); // Update here so unmask uses the original fillChar\n\n    updateMaskInternalsFlag === true && updateMaskInternals();\n    const preMasked = maskValue(unmasked),\n          masked = props.fillMask !== false ? fillWithMask(preMasked) : preMasked,\n          changed = innerValue.value !== masked; // We want to avoid \"flickering\" so we set value immediately\n\n    inp.value !== masked && (inp.value = masked);\n    changed === true && (innerValue.value = masked);\n    document.activeElement === inp && nextTick(() => {\n      if (masked === maskReplaced) {\n        const cursor = props.reverseFillMask === true ? maskReplaced.length : 0;\n        inp.setSelectionRange(cursor, cursor, 'forward');\n        return;\n      }\n\n      if (inputType === 'insertFromPaste' && props.reverseFillMask !== true) {\n        const cursor = end - 1;\n        moveCursor.right(inp, cursor, cursor);\n        return;\n      }\n\n      if (['deleteContentBackward', 'deleteContentForward'].indexOf(inputType) > -1) {\n        const cursor = props.reverseFillMask === true ? end === 0 ? masked.length > preMasked.length ? 1 : 0 : Math.max(0, masked.length - (masked === maskReplaced ? 0 : Math.min(preMasked.length, endReverse) + 1)) + 1 : end;\n        inp.setSelectionRange(cursor, cursor, 'forward');\n        return;\n      }\n\n      if (props.reverseFillMask === true) {\n        if (changed === true) {\n          const cursor = Math.max(0, masked.length - (masked === maskReplaced ? 0 : Math.min(preMasked.length, endReverse + 1)));\n\n          if (cursor === 1 && end === 1) {\n            inp.setSelectionRange(cursor, cursor, 'forward');\n          } else {\n            moveCursor.rightReverse(inp, cursor, cursor);\n          }\n        } else {\n          const cursor = masked.length - endReverse;\n          inp.setSelectionRange(cursor, cursor, 'backward');\n        }\n      } else {\n        if (changed === true) {\n          const cursor = Math.max(0, maskMarked.indexOf(MARKER), Math.min(preMasked.length, end) - 1);\n          moveCursor.right(inp, cursor, cursor);\n        } else {\n          const cursor = end - 1;\n          moveCursor.right(inp, cursor, cursor);\n        }\n      }\n    });\n    const val = props.unmaskedValue === true ? unmaskValue(masked) : masked;\n    String(props.modelValue) !== val && emitValue(val, true);\n  }\n\n  function moveCursorForPaste(inp, start, end) {\n    const preMasked = maskValue(unmaskValue(inp.value));\n    start = Math.max(0, maskMarked.indexOf(MARKER), Math.min(preMasked.length, start));\n    inp.setSelectionRange(start, end, 'forward');\n  }\n\n  const moveCursor = {\n    left(inp, start, end, selection) {\n      const noMarkBefore = maskMarked.slice(start - 1).indexOf(MARKER) === -1;\n      let i = Math.max(0, start - 1);\n\n      for (; i >= 0; i--) {\n        if (maskMarked[i] === MARKER) {\n          start = i;\n          noMarkBefore === true && start++;\n          break;\n        }\n      }\n\n      if (i < 0 && maskMarked[start] !== void 0 && maskMarked[start] !== MARKER) {\n        return moveCursor.right(inp, 0, 0);\n      }\n\n      start >= 0 && inp.setSelectionRange(start, selection === true ? end : start, 'backward');\n    },\n\n    right(inp, start, end, selection) {\n      const limit = inp.value.length;\n      let i = Math.min(limit, end + 1);\n\n      for (; i <= limit; i++) {\n        if (maskMarked[i] === MARKER) {\n          end = i;\n          break;\n        } else if (maskMarked[i - 1] === MARKER) {\n          end = i;\n        }\n      }\n\n      if (i > limit && maskMarked[end - 1] !== void 0 && maskMarked[end - 1] !== MARKER) {\n        return moveCursor.left(inp, limit, limit);\n      }\n\n      inp.setSelectionRange(selection ? start : end, end, 'forward');\n    },\n\n    leftReverse(inp, start, end, selection) {\n      const localMaskMarked = getPaddedMaskMarked(inp.value.length);\n      let i = Math.max(0, start - 1);\n\n      for (; i >= 0; i--) {\n        if (localMaskMarked[i - 1] === MARKER) {\n          start = i;\n          break;\n        } else if (localMaskMarked[i] === MARKER) {\n          start = i;\n\n          if (i === 0) {\n            break;\n          }\n        }\n      }\n\n      if (i < 0 && localMaskMarked[start] !== void 0 && localMaskMarked[start] !== MARKER) {\n        return moveCursor.rightReverse(inp, 0, 0);\n      }\n\n      start >= 0 && inp.setSelectionRange(start, selection === true ? end : start, 'backward');\n    },\n\n    rightReverse(inp, start, end, selection) {\n      const limit = inp.value.length,\n            localMaskMarked = getPaddedMaskMarked(limit),\n            noMarkBefore = localMaskMarked.slice(0, end + 1).indexOf(MARKER) === -1;\n      let i = Math.min(limit, end + 1);\n\n      for (; i <= limit; i++) {\n        if (localMaskMarked[i - 1] === MARKER) {\n          end = i;\n          end > 0 && noMarkBefore === true && end--;\n          break;\n        }\n      }\n\n      if (i > limit && localMaskMarked[end - 1] !== void 0 && localMaskMarked[end - 1] !== MARKER) {\n        return moveCursor.leftReverse(inp, limit, limit);\n      }\n\n      inp.setSelectionRange(selection === true ? start : end, end, 'forward');\n    }\n\n  };\n\n  function onMaskedKeydown(e) {\n    if (shouldIgnoreKey(e) === true) {\n      return;\n    }\n\n    const inp = inputRef.value,\n          start = inp.selectionStart,\n          end = inp.selectionEnd;\n\n    if (e.keyCode === 37 || e.keyCode === 39) {\n      // Left / Right\n      const fn = moveCursor[(e.keyCode === 39 ? 'right' : 'left') + (props.reverseFillMask === true ? 'Reverse' : '')];\n      e.preventDefault();\n      fn(inp, start, end, e.shiftKey);\n    } else if (e.keyCode === 8 // Backspace\n    && props.reverseFillMask !== true && start === end) {\n      moveCursor.left(inp, start, end, true);\n    } else if (e.keyCode === 46 // Delete\n    && props.reverseFillMask === true && start === end) {\n      moveCursor.rightReverse(inp, start, end, true);\n    }\n  }\n\n  function maskValue(val) {\n    if (val === void 0 || val === null || val === '') {\n      return '';\n    }\n\n    if (props.reverseFillMask === true) {\n      return maskValueReverse(val);\n    }\n\n    const mask = computedMask;\n    let valIndex = 0,\n        output = '';\n\n    for (let maskIndex = 0; maskIndex < mask.length; maskIndex++) {\n      const valChar = val[valIndex],\n            maskDef = mask[maskIndex];\n\n      if (typeof maskDef === 'string') {\n        output += maskDef;\n        valChar === maskDef && valIndex++;\n      } else if (valChar !== void 0 && maskDef.regex.test(valChar)) {\n        output += maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar;\n        valIndex++;\n      } else {\n        return output;\n      }\n    }\n\n    return output;\n  }\n\n  function maskValueReverse(val) {\n    const mask = computedMask,\n          firstTokenIndex = maskMarked.indexOf(MARKER);\n    let valIndex = val.length - 1,\n        output = '';\n\n    for (let maskIndex = mask.length - 1; maskIndex >= 0 && valIndex > -1; maskIndex--) {\n      const maskDef = mask[maskIndex];\n      let valChar = val[valIndex];\n\n      if (typeof maskDef === 'string') {\n        output = maskDef + output;\n        valChar === maskDef && valIndex--;\n      } else if (valChar !== void 0 && maskDef.regex.test(valChar)) {\n        do {\n          output = (maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar) + output;\n          valIndex--;\n          valChar = val[valIndex]; // eslint-disable-next-line no-unmodified-loop-condition\n        } while (firstTokenIndex === maskIndex && valChar !== void 0 && maskDef.regex.test(valChar));\n      } else {\n        return output;\n      }\n    }\n\n    return output;\n  }\n\n  function unmaskValue(val) {\n    return typeof val !== 'string' || computedUnmask === void 0 ? typeof val === 'number' ? computedUnmask('' + val) : val : computedUnmask(val);\n  }\n\n  function fillWithMask(val) {\n    if (maskReplaced.length - val.length <= 0) {\n      return val;\n    }\n\n    return props.reverseFillMask === true && val.length > 0 ? maskReplaced.slice(0, -val.length) + val : val + maskReplaced.slice(val.length);\n  }\n\n  return {\n    innerValue,\n    hasMask,\n    moveCursorForPaste,\n    updateMaskValue,\n    onMaskedKeydown\n  };\n}","map":{"version":3,"names":["ref","watch","nextTick","shouldIgnoreKey","NAMED_MASKS","date","datetime","time","fulltime","phone","card","TOKENS","pattern","negate","S","N","A","transform","v","toLocaleUpperCase","a","toLocaleLowerCase","X","x","KEYS","Object","keys","forEach","key","regex","RegExp","tokenRegexMask","join","escRegex","MARKER","String","fromCharCode","useMaskProps","mask","reverseFillMask","Boolean","fillMask","unmaskedValue","props","emit","emitValue","inputRef","maskMarked","maskReplaced","computedMask","computedUnmask","hasMask","innerValue","getInitialMaskedValue","getIsTypeText","autogrow","includes","type","updateMaskInternals","updateMaskValue","value","val","unmaskValue","modelValue","masked","maskValue","fillWithMask","getPaddedMaskMarked","size","length","slice","pad","localMaskMarked","padPos","indexOf","i","localComputedMask","fillChar","fillCharEscaped","replace","unmask","extract","firstMatch","unmaskChar","negateChar","_","char1","esc","token","char2","c","push","unmaskMatcher","extractLast","extractMatcher","map","re","index","unmaskMatch","exec","extractMatch","extractMatcherLength","str","m","shift","split","rawVal","updateMaskInternalsFlag","inputType","inp","end","selectionEnd","endReverse","unmasked","preMasked","changed","document","activeElement","cursor","setSelectionRange","moveCursor","right","Math","max","min","rightReverse","moveCursorForPaste","start","left","selection","noMarkBefore","limit","leftReverse","onMaskedKeydown","e","selectionStart","keyCode","fn","preventDefault","shiftKey","maskValueReverse","valIndex","output","maskIndex","valChar","maskDef","test","firstTokenIndex"],"sources":["C:/Users/82107/Desktop/WEB_YBR/frontend_ybr/node_modules/quasar/src/components/input/use-mask.js"],"sourcesContent":["import { ref, watch, nextTick } from 'vue'\r\n\r\nimport { shouldIgnoreKey } from '../../utils/private/key-composition.js'\r\n\r\n// leave NAMED_MASKS at top of file (code referenced from docs)\r\nconst NAMED_MASKS = {\r\n  date: '####/##/##',\r\n  datetime: '####/##/## ##:##',\r\n  time: '##:##',\r\n  fulltime: '##:##:##',\r\n  phone: '(###) ### - ####',\r\n  card: '#### #### #### ####'\r\n}\r\n\r\nconst TOKENS = {\r\n  '#': { pattern: '[\\\\d]', negate: '[^\\\\d]' },\r\n\r\n  S: { pattern: '[a-zA-Z]', negate: '[^a-zA-Z]' },\r\n  N: { pattern: '[0-9a-zA-Z]', negate: '[^0-9a-zA-Z]' },\r\n\r\n  A: { pattern: '[a-zA-Z]', negate: '[^a-zA-Z]', transform: v => v.toLocaleUpperCase() },\r\n  a: { pattern: '[a-zA-Z]', negate: '[^a-zA-Z]', transform: v => v.toLocaleLowerCase() },\r\n\r\n  X: { pattern: '[0-9a-zA-Z]', negate: '[^0-9a-zA-Z]', transform: v => v.toLocaleUpperCase() },\r\n  x: { pattern: '[0-9a-zA-Z]', negate: '[^0-9a-zA-Z]', transform: v => v.toLocaleLowerCase() }\r\n}\r\n\r\nconst KEYS = Object.keys(TOKENS)\r\nKEYS.forEach(key => {\r\n  TOKENS[ key ].regex = new RegExp(TOKENS[ key ].pattern)\r\n})\r\n\r\nconst\r\n  tokenRegexMask = new RegExp('\\\\\\\\([^.*+?^${}()|([\\\\]])|([.*+?^${}()|[\\\\]])|([' + KEYS.join('') + '])|(.)', 'g'),\r\n  escRegex = /[.*+?^${}()|[\\]\\\\]/g\r\n\r\nconst MARKER = String.fromCharCode(1)\r\n\r\nexport const useMaskProps = {\r\n  mask: String,\r\n  reverseFillMask: Boolean,\r\n  fillMask: [ Boolean, String ],\r\n  unmaskedValue: Boolean\r\n}\r\n\r\nexport default function (props, emit, emitValue, inputRef) {\r\n  let maskMarked, maskReplaced, computedMask, computedUnmask\r\n\r\n  const hasMask = ref(null)\r\n  const innerValue = ref(getInitialMaskedValue())\r\n\r\n  function getIsTypeText () {\r\n    return props.autogrow === true\r\n      || [ 'textarea', 'text', 'search', 'url', 'tel', 'password' ].includes(props.type)\r\n  }\r\n\r\n  watch(() => props.type + props.autogrow, updateMaskInternals)\r\n\r\n  watch(() => props.mask, v => {\r\n    if (v !== void 0) {\r\n      updateMaskValue(innerValue.value, true)\r\n    }\r\n    else {\r\n      const val = unmaskValue(innerValue.value)\r\n      updateMaskInternals()\r\n      props.modelValue !== val && emit('update:modelValue', val)\r\n    }\r\n  })\r\n\r\n  watch(() => props.fillMask + props.reverseFillMask, () => {\r\n    hasMask.value === true && updateMaskValue(innerValue.value, true)\r\n  })\r\n\r\n  watch(() => props.unmaskedValue, () => {\r\n    hasMask.value === true && updateMaskValue(innerValue.value)\r\n  })\r\n\r\n  function getInitialMaskedValue () {\r\n    updateMaskInternals()\r\n\r\n    if (hasMask.value === true) {\r\n      const masked = maskValue(unmaskValue(props.modelValue))\r\n\r\n      return props.fillMask !== false\r\n        ? fillWithMask(masked)\r\n        : masked\r\n    }\r\n\r\n    return props.modelValue\r\n  }\r\n\r\n  function getPaddedMaskMarked (size) {\r\n    if (size < maskMarked.length) {\r\n      return maskMarked.slice(-size)\r\n    }\r\n\r\n    let pad = '', localMaskMarked = maskMarked\r\n    const padPos = localMaskMarked.indexOf(MARKER)\r\n\r\n    if (padPos > -1) {\r\n      for (let i = size - localMaskMarked.length; i > 0; i--) {\r\n        pad += MARKER\r\n      }\r\n\r\n      localMaskMarked = localMaskMarked.slice(0, padPos) + pad + localMaskMarked.slice(padPos)\r\n    }\r\n\r\n    return localMaskMarked\r\n  }\r\n\r\n  function updateMaskInternals () {\r\n    hasMask.value = props.mask !== void 0\r\n      && props.mask.length > 0\r\n      && getIsTypeText()\r\n\r\n    if (hasMask.value === false) {\r\n      computedUnmask = void 0\r\n      maskMarked = ''\r\n      maskReplaced = ''\r\n      return\r\n    }\r\n\r\n    const\r\n      localComputedMask = NAMED_MASKS[ props.mask ] === void 0\r\n        ? props.mask\r\n        : NAMED_MASKS[ props.mask ],\r\n      fillChar = typeof props.fillMask === 'string' && props.fillMask.length > 0\r\n        ? props.fillMask.slice(0, 1)\r\n        : '_',\r\n      fillCharEscaped = fillChar.replace(escRegex, '\\\\$&'),\r\n      unmask = [],\r\n      extract = [],\r\n      mask = []\r\n\r\n    let\r\n      firstMatch = props.reverseFillMask === true,\r\n      unmaskChar = '',\r\n      negateChar = ''\r\n\r\n    localComputedMask.replace(tokenRegexMask, (_, char1, esc, token, char2) => {\r\n      if (token !== void 0) {\r\n        const c = TOKENS[ token ]\r\n        mask.push(c)\r\n        negateChar = c.negate\r\n        if (firstMatch === true) {\r\n          extract.push('(?:' + negateChar + '+)?(' + c.pattern + '+)?(?:' + negateChar + '+)?(' + c.pattern + '+)?')\r\n          firstMatch = false\r\n        }\r\n        extract.push('(?:' + negateChar + '+)?(' + c.pattern + ')?')\r\n      }\r\n      else if (esc !== void 0) {\r\n        unmaskChar = '\\\\' + (esc === '\\\\' ? '' : esc)\r\n        mask.push(esc)\r\n        unmask.push('([^' + unmaskChar + ']+)?' + unmaskChar + '?')\r\n      }\r\n      else {\r\n        const c = char1 !== void 0 ? char1 : char2\r\n        unmaskChar = c === '\\\\' ? '\\\\\\\\\\\\\\\\' : c.replace(escRegex, '\\\\\\\\$&')\r\n        mask.push(c)\r\n        unmask.push('([^' + unmaskChar + ']+)?' + unmaskChar + '?')\r\n      }\r\n    })\r\n\r\n    const\r\n      unmaskMatcher = new RegExp(\r\n        '^'\r\n        + unmask.join('')\r\n        + '(' + (unmaskChar === '' ? '.' : '[^' + unmaskChar + ']') + '+)?'\r\n        + '$'\r\n      ),\r\n      extractLast = extract.length - 1,\r\n      extractMatcher = extract.map((re, index) => {\r\n        if (index === 0 && props.reverseFillMask === true) {\r\n          return new RegExp('^' + fillCharEscaped + '*' + re)\r\n        }\r\n        else if (index === extractLast) {\r\n          return new RegExp(\r\n            '^' + re\r\n            + '(' + (negateChar === '' ? '.' : negateChar) + '+)?'\r\n            + (props.reverseFillMask === true ? '$' : fillCharEscaped + '*')\r\n          )\r\n        }\r\n\r\n        return new RegExp('^' + re)\r\n      })\r\n\r\n    computedMask = mask\r\n    computedUnmask = val => {\r\n      const unmaskMatch = unmaskMatcher.exec(val)\r\n      if (unmaskMatch !== null) {\r\n        val = unmaskMatch.slice(1).join('')\r\n      }\r\n\r\n      const\r\n        extractMatch = [],\r\n        extractMatcherLength = extractMatcher.length\r\n\r\n      for (let i = 0, str = val; i < extractMatcherLength; i++) {\r\n        const m = extractMatcher[ i ].exec(str)\r\n\r\n        if (m === null) {\r\n          break\r\n        }\r\n\r\n        str = str.slice(m.shift().length)\r\n        extractMatch.push(...m)\r\n      }\r\n      if (extractMatch.length > 0) {\r\n        return extractMatch.join('')\r\n      }\r\n\r\n      return val\r\n    }\r\n    maskMarked = mask.map(v => (typeof v === 'string' ? v : MARKER)).join('')\r\n    maskReplaced = maskMarked.split(MARKER).join(fillChar)\r\n  }\r\n\r\n  function updateMaskValue (rawVal, updateMaskInternalsFlag, inputType) {\r\n    const\r\n      inp = inputRef.value,\r\n      end = inp.selectionEnd,\r\n      endReverse = inp.value.length - end,\r\n      unmasked = unmaskValue(rawVal)\r\n\r\n    // Update here so unmask uses the original fillChar\r\n    updateMaskInternalsFlag === true && updateMaskInternals()\r\n\r\n    const\r\n      preMasked = maskValue(unmasked),\r\n      masked = props.fillMask !== false\r\n        ? fillWithMask(preMasked)\r\n        : preMasked,\r\n      changed = innerValue.value !== masked\r\n\r\n    // We want to avoid \"flickering\" so we set value immediately\r\n    inp.value !== masked && (inp.value = masked)\r\n\r\n    changed === true && (innerValue.value = masked)\r\n\r\n    document.activeElement === inp && nextTick(() => {\r\n      if (masked === maskReplaced) {\r\n        const cursor = props.reverseFillMask === true ? maskReplaced.length : 0\r\n        inp.setSelectionRange(cursor, cursor, 'forward')\r\n\r\n        return\r\n      }\r\n\r\n      if (inputType === 'insertFromPaste' && props.reverseFillMask !== true) {\r\n        const cursor = end - 1\r\n        moveCursor.right(inp, cursor, cursor)\r\n\r\n        return\r\n      }\r\n\r\n      if ([ 'deleteContentBackward', 'deleteContentForward' ].indexOf(inputType) > -1) {\r\n        const cursor = props.reverseFillMask === true\r\n          ? (\r\n              end === 0\r\n                ? (masked.length > preMasked.length ? 1 : 0)\r\n                : Math.max(0, masked.length - (masked === maskReplaced ? 0 : Math.min(preMasked.length, endReverse) + 1)) + 1\r\n            )\r\n          : end\r\n\r\n        inp.setSelectionRange(cursor, cursor, 'forward')\r\n        return\r\n      }\r\n\r\n      if (props.reverseFillMask === true) {\r\n        if (changed === true) {\r\n          const cursor = Math.max(0, masked.length - (masked === maskReplaced ? 0 : Math.min(preMasked.length, endReverse + 1)))\r\n\r\n          if (cursor === 1 && end === 1) {\r\n            inp.setSelectionRange(cursor, cursor, 'forward')\r\n          }\r\n          else {\r\n            moveCursor.rightReverse(inp, cursor, cursor)\r\n          }\r\n        }\r\n        else {\r\n          const cursor = masked.length - endReverse\r\n          inp.setSelectionRange(cursor, cursor, 'backward')\r\n        }\r\n      }\r\n      else {\r\n        if (changed === true) {\r\n          const cursor = Math.max(0, maskMarked.indexOf(MARKER), Math.min(preMasked.length, end) - 1)\r\n          moveCursor.right(inp, cursor, cursor)\r\n        }\r\n        else {\r\n          const cursor = end - 1\r\n          moveCursor.right(inp, cursor, cursor)\r\n        }\r\n      }\r\n    })\r\n\r\n    const val = props.unmaskedValue === true\r\n      ? unmaskValue(masked)\r\n      : masked\r\n\r\n    String(props.modelValue) !== val && emitValue(val, true)\r\n  }\r\n\r\n  function moveCursorForPaste (inp, start, end) {\r\n    const preMasked = maskValue(unmaskValue(inp.value))\r\n\r\n    start = Math.max(0, maskMarked.indexOf(MARKER), Math.min(preMasked.length, start))\r\n\r\n    inp.setSelectionRange(start, end, 'forward')\r\n  }\r\n\r\n  const moveCursor = {\r\n    left (inp, start, end, selection) {\r\n      const noMarkBefore = maskMarked.slice(start - 1).indexOf(MARKER) === -1\r\n      let i = Math.max(0, start - 1)\r\n\r\n      for (; i >= 0; i--) {\r\n        if (maskMarked[ i ] === MARKER) {\r\n          start = i\r\n          noMarkBefore === true && start++\r\n          break\r\n        }\r\n      }\r\n\r\n      if (\r\n        i < 0\r\n        && maskMarked[ start ] !== void 0\r\n        && maskMarked[ start ] !== MARKER\r\n      ) {\r\n        return moveCursor.right(inp, 0, 0)\r\n      }\r\n\r\n      start >= 0 && inp.setSelectionRange(\r\n        start,\r\n        selection === true ? end : start, 'backward'\r\n      )\r\n    },\r\n\r\n    right (inp, start, end, selection) {\r\n      const limit = inp.value.length\r\n      let i = Math.min(limit, end + 1)\r\n\r\n      for (; i <= limit; i++) {\r\n        if (maskMarked[ i ] === MARKER) {\r\n          end = i\r\n          break\r\n        }\r\n        else if (maskMarked[ i - 1 ] === MARKER) {\r\n          end = i\r\n        }\r\n      }\r\n\r\n      if (\r\n        i > limit\r\n        && maskMarked[ end - 1 ] !== void 0\r\n        && maskMarked[ end - 1 ] !== MARKER\r\n      ) {\r\n        return moveCursor.left(inp, limit, limit)\r\n      }\r\n\r\n      inp.setSelectionRange(selection ? start : end, end, 'forward')\r\n    },\r\n\r\n    leftReverse (inp, start, end, selection) {\r\n      const\r\n        localMaskMarked = getPaddedMaskMarked(inp.value.length)\r\n      let i = Math.max(0, start - 1)\r\n\r\n      for (; i >= 0; i--) {\r\n        if (localMaskMarked[ i - 1 ] === MARKER) {\r\n          start = i\r\n          break\r\n        }\r\n        else if (localMaskMarked[ i ] === MARKER) {\r\n          start = i\r\n          if (i === 0) {\r\n            break\r\n          }\r\n        }\r\n      }\r\n\r\n      if (\r\n        i < 0\r\n        && localMaskMarked[ start ] !== void 0\r\n        && localMaskMarked[ start ] !== MARKER\r\n      ) {\r\n        return moveCursor.rightReverse(inp, 0, 0)\r\n      }\r\n\r\n      start >= 0 && inp.setSelectionRange(\r\n        start,\r\n        selection === true ? end : start, 'backward'\r\n      )\r\n    },\r\n\r\n    rightReverse (inp, start, end, selection) {\r\n      const\r\n        limit = inp.value.length,\r\n        localMaskMarked = getPaddedMaskMarked(limit),\r\n        noMarkBefore = localMaskMarked.slice(0, end + 1).indexOf(MARKER) === -1\r\n      let i = Math.min(limit, end + 1)\r\n\r\n      for (; i <= limit; i++) {\r\n        if (localMaskMarked[ i - 1 ] === MARKER) {\r\n          end = i\r\n          end > 0 && noMarkBefore === true && end--\r\n          break\r\n        }\r\n      }\r\n\r\n      if (\r\n        i > limit\r\n        && localMaskMarked[ end - 1 ] !== void 0\r\n        && localMaskMarked[ end - 1 ] !== MARKER\r\n      ) {\r\n        return moveCursor.leftReverse(inp, limit, limit)\r\n      }\r\n\r\n      inp.setSelectionRange(selection === true ? start : end, end, 'forward')\r\n    }\r\n  }\r\n\r\n  function onMaskedKeydown (e) {\r\n    if (shouldIgnoreKey(e) === true) {\r\n      return\r\n    }\r\n\r\n    const\r\n      inp = inputRef.value,\r\n      start = inp.selectionStart,\r\n      end = inp.selectionEnd\r\n\r\n    if (e.keyCode === 37 || e.keyCode === 39) { // Left / Right\r\n      const fn = moveCursor[ (e.keyCode === 39 ? 'right' : 'left') + (props.reverseFillMask === true ? 'Reverse' : '') ]\r\n\r\n      e.preventDefault()\r\n      fn(inp, start, end, e.shiftKey)\r\n    }\r\n    else if (\r\n      e.keyCode === 8 // Backspace\r\n      && props.reverseFillMask !== true\r\n      && start === end\r\n    ) {\r\n      moveCursor.left(inp, start, end, true)\r\n    }\r\n    else if (\r\n      e.keyCode === 46 // Delete\r\n      && props.reverseFillMask === true\r\n      && start === end\r\n    ) {\r\n      moveCursor.rightReverse(inp, start, end, true)\r\n    }\r\n  }\r\n\r\n  function maskValue (val) {\r\n    if (val === void 0 || val === null || val === '') { return '' }\r\n\r\n    if (props.reverseFillMask === true) {\r\n      return maskValueReverse(val)\r\n    }\r\n\r\n    const mask = computedMask\r\n\r\n    let valIndex = 0, output = ''\r\n\r\n    for (let maskIndex = 0; maskIndex < mask.length; maskIndex++) {\r\n      const\r\n        valChar = val[ valIndex ],\r\n        maskDef = mask[ maskIndex ]\r\n\r\n      if (typeof maskDef === 'string') {\r\n        output += maskDef\r\n        valChar === maskDef && valIndex++\r\n      }\r\n      else if (valChar !== void 0 && maskDef.regex.test(valChar)) {\r\n        output += maskDef.transform !== void 0\r\n          ? maskDef.transform(valChar)\r\n          : valChar\r\n        valIndex++\r\n      }\r\n      else {\r\n        return output\r\n      }\r\n    }\r\n\r\n    return output\r\n  }\r\n\r\n  function maskValueReverse (val) {\r\n    const\r\n      mask = computedMask,\r\n      firstTokenIndex = maskMarked.indexOf(MARKER)\r\n\r\n    let valIndex = val.length - 1, output = ''\r\n\r\n    for (let maskIndex = mask.length - 1; maskIndex >= 0 && valIndex > -1; maskIndex--) {\r\n      const maskDef = mask[ maskIndex ]\r\n\r\n      let valChar = val[ valIndex ]\r\n\r\n      if (typeof maskDef === 'string') {\r\n        output = maskDef + output\r\n        valChar === maskDef && valIndex--\r\n      }\r\n      else if (valChar !== void 0 && maskDef.regex.test(valChar)) {\r\n        do {\r\n          output = (maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar) + output\r\n          valIndex--\r\n          valChar = val[ valIndex ]\r\n        // eslint-disable-next-line no-unmodified-loop-condition\r\n        } while (firstTokenIndex === maskIndex && valChar !== void 0 && maskDef.regex.test(valChar))\r\n      }\r\n      else {\r\n        return output\r\n      }\r\n    }\r\n\r\n    return output\r\n  }\r\n\r\n  function unmaskValue (val) {\r\n    return typeof val !== 'string' || computedUnmask === void 0\r\n      ? (typeof val === 'number' ? computedUnmask('' + val) : val)\r\n      : computedUnmask(val)\r\n  }\r\n\r\n  function fillWithMask (val) {\r\n    if (maskReplaced.length - val.length <= 0) {\r\n      return val\r\n    }\r\n\r\n    return props.reverseFillMask === true && val.length > 0\r\n      ? maskReplaced.slice(0, -val.length) + val\r\n      : val + maskReplaced.slice(val.length)\r\n  }\r\n\r\n  return {\r\n    innerValue,\r\n    hasMask,\r\n    moveCursorForPaste,\r\n    updateMaskValue,\r\n    onMaskedKeydown\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}